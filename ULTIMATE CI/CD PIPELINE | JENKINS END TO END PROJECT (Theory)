
ULTIMATE CI/CD PIPELINE | JENKINS END TO END PROJECT
======================================================



GitHub Project URL: https://github.com/iam-veeramalla/Jenkins-Zero-To-Hero/tree/main/java-maven-sonar-argocd-helm-k8s
------------------------------------------------------------------------------------------------------------------------


There are 2 Git Repository 

- For Source Code

- For Application Manifest



Jenkins Pipeline is Only doing the Continous Integration & We are Using ArgoCD (GiOps) Approach for Continous Delivery.



- Developers has store their Code in the Git Repository, We have Jenkins as an Orchestrator Which is Responsible for Watching Commits or Pull Requests in this Repo. We will Use GitHub WebHook and Configure that Jenkins Should be Trigerred on Commit, Pull Request or Issues & We have Configured this in GitHub Settings Page.


- Once the Jenkins is Trigerred by the GitHub WebHook we have Written Jenkins File in which we have Defined a Set of Actions which needs to be Performed. By Using Maven we will Build the Application


1. Install the necessary Jenkins plugins:
   1.1 Git plugin
   1.2 Maven Integration plugin
   1.3 Pipeline plugin
   1.4 Kubernetes Continuous Deploy plugin

2. Create a new Jenkins pipeline:
   2.1 In Jenkins, create a new pipeline job and configure it with the Git repository URL for the Java application.
   2.2 Add a Jenkinsfile to the Git repository to define the pipeline stages.

3. Define the pipeline stages:
    Stage 1: Checkout the source code from Git.
    Stage 2: Build the Java application using Maven.
    Stage 3: Run unit tests using JUnit and Mockito.
    Stage 4: Run SonarQube analysis to check the code quality.
    Stage 5: Package the application into a JAR file.
    Stage 6: Deploy the application to a test environment using Helm.
    Stage 7: Run user acceptance tests on the deployed application.
    Stage 8: Promote the application to a production environment using Argo CD.

4. Configure Jenkins pipeline stages:
    Stage 1: Use the Git plugin to check out the source code from the Git repository.
    Stage 2: Use the Maven Integration plugin to build the Java application.
    Stage 3: Use the JUnit and Mockito plugins to run unit tests.
    Stage 4: Use the SonarQube plugin to analyze the code quality of the Java application.
    Stage 5: Use the Maven Integration plugin to package the application into a JAR file.
    Stage 6: Use the Kubernetes Continuous Deploy plugin to deploy the application to a test environment using Helm.
    Stage 7: Use a testing framework like Selenium to run user acceptance tests on the deployed application.
    Stage 8: Use Argo CD to promote the application to a production environment.

5. Set up Argo CD:
    Install Argo CD on the Kubernetes cluster.
    Set up a Git repository for Argo CD to track the changes in the Helm charts and Kubernetes manifests.
    Create a Helm chart for the Java application that includes the Kubernetes manifests and Helm values.
    Add the Helm chart to the Git repository that Argo CD is tracking.

6. Configure Jenkins pipeline to integrate with Argo CD:
   6.1 Add the Argo CD API token to Jenkins credentials.
   6.2 Update the Jenkins pipeline to include the Argo CD deployment stage.

7. Run the Jenkins pipeline:
   7.1 Trigger the Jenkins pipeline to start the CI/CD process for the Java application.
   7.2 Monitor the pipeline stages and fix any issues that arise.







================================================================================================================================================================================================================================================

Interview Prep
================


We have a Git Repository where we have our Application Source Code, As soon as the Developer raises a New Pull Request to this Git Repository we have Configured WebHooks using the WebHooks we Trigger the Jenkins Pipelines. We have Used Declarative Jenkins Pipelines because Declarative Pipelines are Easy pipelines to Write and Collaborate and as part of this declarative Jenkins pipeline we run multiple stages so some of these stages are

—  The First stage would be the Build Stage using Maven as our Build Language what we do is we Build the Application and if the build stage is successful or if the application is built successfully where we also execute some Unit tests 



— The next stage would be we will perform Static Code Analysis and using the static code analysis we will Verify that this application is not exposed to any static code 



— And after that we also have some SAST and DAST Tools where we verify the Application Security if this new change that the developer is Writing Introduces any Security Vulnerability if any of these things fail then we would send email notification or we would send slack notifications that we have configured.



— If all of these stages are successfully done then we would go forward and we would create a Docker image so we are running simple shell targets to create the docker image out of the docker file which we have stored in the Git repository itself and as soon as the docker image is created again using the Shell commands we push this Docker image which is ECR, Quay.io.



—This is Our CI Process so for CI process we are using Jenkins and coming to the CD process once the docker image is pushed to the Elastic Container Registry (ECR) or Quay.io,  We have a Kubernetes cluster Inside the Kubernetes cluster we have deployed two continuous delivery tools

- Argo Image Updater
- Argo CD

Both of these things are Kubernetes Controllers that we have deployed on our Kubernetes cluster what they do is the first tool that is Argo Image updater it would continuously monitor the image registry and as soon as a new image is created it will pick the new image and it will update the new image in another Git Repository that we have and this git repository is purely for the image Manifest that is our Helm Charts or our Kustomize.



— As soon as this GitHub repository is updated with the New Image then the other Kubernetes Controller that we have which is Argo CD it takes the new image and it deploys on the Kubernetes cluster so this is our continuous delivery process so this is how we have set up Continuous Integration and Continuous Delivery in our organization.
