Day 19 | Jenkins ZERO to HERO | 3 Projects Live |Docker Agent |Interview Questions 
==================================================================================


Below is the GitHub Repository Used Today
Link - https://github.com/iam-veeramalla/Jenkins-Zero-To-Hero



# AWS EC2 Instance  ->  Go to AWS Console  ->  Launch instances



# Install Jenkins.
Pre-Requisites to Install Jenkins is Java (JDK) So We Have to Install That First



# Update the System Files
sudo apt update


# Install Java
sudo apt install openjdk-17-jre



# Verify Java is Installed
java -version



# Now, you can proceed with installing Jenkins
curl -fsSL https://pkg.jenkins.io/debian/jenkins.io-2023.key | sudo tee \
  /usr/share/keyrings/jenkins-keyring.asc > /dev/null
echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \
  https://pkg.jenkins.io/debian binary/ | sudo tee \
  /etc/apt/sources.list.d/jenkins.list > /dev/null
sudo apt-get update
sudo apt-get install jenkins





# **Note: ** By default, Jenkins will not be accessible to the external world due to the inbound traffic restriction by AWS. Open port 8080 in the inbound traffic rules as show below.



- EC2 > Instances > Click on 

- In the bottom tabs -> Click on Security

- Security groups

- Add inbound traffic rules as shown in the image (you can just allow TCP 8080 as well, in my case, I allowed All traffic).






# Login to Jenkins using the below URL:


- http://:8080 [You can get the ec2-instance-public-ip-address from your AWS EC2 console page]

- Note: If you are not interested in allowing All Traffic to your EC2 instance 1. Delete the inbound traffic rule for your instance 2. Edit the inbound traffic rule to only allow custom TCP port 8080

- After you login to Jenkins, - Run the command to copy the Jenkins Admin Password - sudo cat /var/lib/jenkins/secrets/initialAdminPassword - Enter the Administrator password





# Click on Install suggested plugins    & Wait for the Jenkins to Install suggested plugins



# Create First Admin User or Skip the step [If you want to use this Jenkins instance for future use-cases as well, better to create admin user]



# Jenkins Installation is Successful. You can now starting using the Jenkins







# Docker Slave Configuration 


Run the below command to Install Docker

sudo apt update
sudo apt install docker.io 





# Grant Jenkins user and Ubuntu user permission to docker deamon.

sudo su - 

usermod -aG docker jenkins

usermod -aG docker ubuntu

systemctl restart docker


su - jenkins 

docker run hello-world  [To check if Docker is Installed or Not]



# Once you are done with the above steps, it is better to restart Jenkins.


http://<ec2-instance-public-ip>:8080/restart


- The docker agent configuration is now successful.






# Install the Docker Pipeline plugin in Jenkins:


- Log in to Jenkins.

- Go to Manage Jenkins > Manage Plugins.

- In the Available tab, search for "Docker Pipeline".

- Select the plugin and click the Install button.

- Restart Jenkins after the plugin is installed.




# Wait for the Jenkins to be restarted.




# Go to Settings  ->  Plugins   -> Provide a Name to the Job and Select Pipeline



# Pipeline Script From SCM 	-> Provide This URL "https://github.com/iam-veeramalla/Jenkins-Zero-To-Hero"



# Check If the Branch is Master or Main and Enter Detail as per that



# Script path  [my-first-pipeline/Jenkinsfile]




# Click on Build Now 



# After few Seconds we will have to  run  "docker ps"  Command and it will show that a Docker Container Got Spun Up and Once the Task is Completed the Container Got Destroyed



# docker ps
CONTAINER ID   IMAGE            COMMAND                  CREATED         STATUS                  PORTS     NAMES
abca35ada12f   node:16-alpine   "docker-entrypoint.s…"   2 seconds ago   Up Less than a second             vigorous_shockley






---------------------------------------------------



# Docker Agents in Jenkins Pipeline
====================================



Using Docker agents in Jenkins pipelines offers several benefits, particularly in Enhancing Consistency, Scalability, and Flexibility.
---------------------------------------------------------------------------------------------------------------------------------------



1. Consistency in Build Environment

- Isolation: Each Docker container runs in an isolated environment, ensuring that dependencies and configurations are uniform across different builds and stages. This avoids the classic "works on my machine" problem.


- Version Control: With Docker images, specific versions of tools and dependencies can be pinned, ensuring that the environment remains consistent, even over time.






2. Scalability and Resource Efficiency

- On-Demand Containers: Docker agents allow Jenkins to spawn lightweight containers dynamically when needed. This makes it easier to scale pipelines up or down based on demand, without the need for persistent, heavyweight virtual machines.


- Efficient Resource Utilization: Containers are lightweight compared to traditional virtual machines, leading to lower resource overhead, faster spin-up times, and more efficient resource usage.






3. Simplified Dependency Management

- Pre-packaged Environments: Each Docker image can contain all the tools, libraries, and dependencies required for a specific job, simplifying the management of the build environment. This eliminates the need to install dependencies on Jenkins agents.


- Customizable: You can build custom Docker images tailored to your specific pipeline needs, allowing fine-grained control over the environment.






4. Improved Security

- Isolation of Jobs: Since containers are isolated from the host system, they provide an additional security layer, preventing build jobs from interfering with the Jenkins master or other jobs running in parallel.


- Limited Scope: By controlling which Docker images are used in the pipeline, you limit the attack surface of your Jenkins agents.






5. Flexibility in Multi-Stage Pipelines

- Multiple Environments per Stage: With Docker, each stage of a multi-stage pipeline can run in a different container tailored to the needs of that specific stage. This is useful when different programming languages, tools, or versions are required for different stages of the pipeline.


- Parallelism: Docker agents allow multiple containers to run in parallel, enabling the execution of different parts of the pipeline simultaneously, which speeds up the overall process.






6. Portability

- Consistent Across Platforms: Docker containers ensure that the Jenkins pipeline can run across different platforms (e.g., Linux, Windows) with minimal configuration changes. This allows teams to easily transition workloads between environments.






7. Simplified Pipeline as Code

- Declarative Pipelines: By using Docker agents, Jenkins pipelines can be declared and versioned in code (using Jenkinsfiles). The environment setup is abstracted through Docker, reducing the complexity of configuring agents manually.






8. Simpler Cleanup and Maintenance


- Ephemeral Agents: Docker containers can be easily discarded after use, making it easier to clean up resources and preventing agent clutter in long-running Jenkins environments.


- No Need for Long-lived Agents: Since containers are lightweight and easily spun up, there’s less need for long-lived, manually configured Jenkins agents.


- Using Docker agents helps to streamline the CI/CD process in Jenkins by offering a flexible, scalable, and consistent approach to managing build and test environments.



