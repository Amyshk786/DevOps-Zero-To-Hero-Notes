


Day-26 | Multi Stage Docker Builds | Reduce Image Size by 800 % | Distroless Container Images
=================================================================================================




# GitHub Repo for Multi Stage Builds Used in Today's Lecture
Link - https://github.com/iam-veeramalla/Docker-Zero-to-Hero/tree/main/examples/golang-multi-stage-docker-build


# For Distro-Less Images (Java, Python etc..)
Link - https://github.com/GoogleContainerTools/distroless/tree/main



- By Using Distro-Less Images You Can Improve the Efficiency and We Can Get the Maximum Benefit of Multi Stage Docker Build




# Multi-Stage Docker Builds:
=============================
Multi-stage builds allow Docker Users to create more Efficient and Smaller Container Images by using multiple FROM statements in a Dockerfile. Each FROM starts a new stage in the build process, and you can selectively copy artifacts from one stage to another. This is particularly useful when the final image needs only certain binaries or files, eliminating the need to ship build tools and unnecessary dependencies in the final image.








# Key Benefits of Multi-Stage Builds:
======================================

1) Smaller Images: By copying only the required files from a build stage into the final image, you can minimize the size of the image.


2) Modular and Readable Dockerfiles: Since each stage has its own purpose, you can organize the Dockerfile better, improving readability.


3) Reusability: Stages can be reused across different projects, making it easier to maintain consistency across images.






# How Multi-Stage Builds Work: Each stage in a multi-stage Dockerfile is defined using a FROM statement. Only the final stage is retained when the container is built.






# Example:
===========


# Stage 1: Build Stage
FROM golang:1.18 AS build-stage
WORKDIR /app
COPY . .
RUN go build -o main .

# Stage 2: Final Image
FROM alpine:3.16
WORKDIR /app
COPY --from=build-stage /app/main .  # Copy the binary from the build stage
CMD ["./main"]







# In this example:
=================

- The first stage uses the Go image (golang:1.18) to compile the code. It creates a binary main.

- The second stage uses a lightweight alpine image, where only the binary is copied, reducing the final image size.






# Best Practices for Multi-Stage Builds:
=========================================

- Use the smallest possible base images for the final stage, e.g., Alpine, Distroless, or scratch.

- Keep the number of stages to the minimum required for optimal performance and size.

- Name your stages for clarity and readability, e.g., AS build-stage.








--------------------------------------------------- 


# Distroless Images:
====================

Distroless images are minimal container images that contain only the application and its dependencies, without a full operating system or package manager. They are designed to minimize security vulnerabilities and attack surfaces by removing unnecessary libraries and utilities.

Distroless images are part of Google's container optimization efforts. Instead of including shell utilities like bash or sh, these images focus purely on running the application.





# Key Benefits of Distroless Images:
=====================================

- Smaller Attack Surface: Fewer libraries and tools in the image mean fewer security vulnerabilities.


- Smaller Image Size: Without a full OS, the images are significantly smaller, which reduces disk space usage and speeds up deployments.


- Performance Improvement: The reduction in unnecessary components may lead to faster startup times.


- Improved Security: The absence of utilities like shell reduces the risk of container escape attacks and other vulnerabilities.





# Using Distroless Images: To use a Distroless image, simply use it as the base in your Dockerfile. Here's an example with a Go application:




# Stage 1: Build Stage
FROM golang:1.18 AS builder
WORKDIR /app
COPY . .
RUN go build -o main .

# Stage 2: Use Distroless for final image
FROM gcr.io/distroless/base
COPY --from=builder /app/main /
CMD ["/main"]








# Types of Distroless Images:
============================

- Base: Contains essential libraries like glibc and is ideal for statically compiled languages like Go and Rust.

- Java, Python, Node.js: Distroless also provides language-specific images that include the necessary runtime environments but avoid unnecessary packages.









# Best Practices with Distroless Images:
==========================================

- Use for production applications to ensure maximum security and efficiency.

- Make sure your application doesn't need utilities like a shell or debugging tools since Distroless images don't provide them.

- Ensure you have good logging and monitoring in place since troubleshooting inside a Distroless container may be more challenging without shell access.







--------------------------------------------------- 


# Comparison: Multi-Stage Builds vs. Distroless Images
======================================================

- Multi-Stage Builds: Primarily used to optimize image size by splitting the build process into different stages, allowing for the exclusion of build-time dependencies.


- Distroless Images: Minimal images focused on security by including only the application and necessary libraries, with no shell or OS utilities.




# Conclusion - However, both can be used together. For example, you can use a multi-stage build to compile your application and use a Distroless image for the final runtime environment:



# Stage 1: Build Stage
FROM golang:1.18 AS builder
WORKDIR /app
COPY . .
RUN go build -o main .

# Stage 2: Final Image using Distroless
FROM gcr.io/distroless/base
COPY --from=builder /app/main /
CMD ["/main"]






--------------------------------------------------- 

Practical of Dockerfile Without Multi-Stage
============================================


- Launch a EC2 Instance


- sudo apt update 


- sudo apt-get install docker.io -y


- cd Docker-Zero-to-Hero/examples/golang-multi-stage-docker-build/dockerfile-without-multistage 


- docker build -t simplecalculator .



Output - 

docker images  [We Can see the simplecalculator Image size is Showing as 643 MB Without Using Multi-Stage Docker]


ubuntu@ip-172-31-46-247:~/Docker-Zero-to-Hero/examples/golang-multi-stage-docker-build/dockerfile-without-multistage$ docker images


REPOSITORY         TAG       IMAGE ID       CREATED         SIZE
simplecalculator   latest    928dfa0428b8   2 minutes ago   643MB
ubuntu             latest    65ae7a6f3544   2 weeks ago     78.1MB
hello-world        latest    74cc54e27dc4   6 months ago    10.1kB




--------------------------------------------------- 








--------------------------------------------------- 

# HERE STARTS THE MAGIC OF MULTI STAGE BUILD
============================================



- cd ..


- ls  [Hum "dockerfile-without-multistage" Directory se Bahar aye h Jaha Humari Multi-Stage wali file h]

Dockerfile  README.md  calculator.go  dockerfile-without-multistage



- docker build -t simplecalculator-using-multi-stage .



Output - [Now we Can See the Magic of Multi-Stage Docker The Size of "simplecalculator-using-multi-stage" is Reduced to 1.96 MB]

ubuntu@ip-172-31-46-247:~/Docker-Zero-to-Hero/examples/golang-multi-stage-docker-build$ docker images


REPOSITORY                           TAG       IMAGE ID       CREATED              SIZE
<none>                               <none>    d5405ac22f69   About a minute ago   643MB
simplecalculator-using-multi-stage   latest    f2a067ef1d96   About a minute ago   1.96MB
simplecalculator                     latest    928dfa0428b8   9 minutes ago        643MB
ubuntu                               latest    65ae7a6f3544   2 weeks ago          78.1MB
hello-world                          latest    74cc54e27dc4   6 months ago         10.1kB



