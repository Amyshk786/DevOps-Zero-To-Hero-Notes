Day-34 | KUBERNETES DEPLOYMENT | REPLICASETS
==============================================

A pod.yaml manifest is nothing but a running specification of your Docker container.

In Kubernetes, "container," "pod," and "deployment" refer to different concepts that play distinct roles in managing applications. Hereâ€™s a breakdown of each:



### 1. Container

- **Definition**: A Container is a Lightweight, Portable unit that packages an application and its dependencies, ensuring it runs consistently across different environments.


- **Function**: Containers encapsulate the application code, libraries, and runtime needed to run an application.


- **Example**: Docker is a popular containerization platform used to create and manage containers.





---------------------------------



### 2. Pod

- **Definition**: A pod is the Smallest Deployable unit in Kubernetes and can contain one or more containers that share the same network namespace and storage.


- **Function**: Pods are designed to host closely related containers that need to work together. They share the same IP address and can communicate easily with each other.


- **Example**: A pod might contain a web server container and a logging container that together manage a web application.





---------------------------------



### 3. Deployment
- **Definition**: A deployment is a higher-level abstraction that manages the lifecycle of pods, including scaling, updating, and rolling back. [Auto Scaling, Auto Healing, Zero Down Time]


- **Function**: Deployments ensure that the desired number of pod replicas are running and handle updates to the application without downtime. They provide declarative updates to applications.


- **Example**: You can define a deployment to maintain three replicas of a web application pod and automatically update those pods when a new version is available.





---------------------------------


### Summary

- **Containers** are the individual units of applications.


- **Pods** group one or more containers that need to work together.


- **Deployments** manage the pods, ensuring that the desired state is maintained and allowing for scaling and updates.

These three components work together to enable effective application deployment and management in a Kubernetes environment.







------------------------------------------------------------


# Kubernetes Suggest us to create A Pod using a Deployment Resource and what this Deployment resource will do is Firstly it will create something called as a Replica Set which is your Kubernetes Controller and The Replica-Set will Roll Out your Pods. Inside Our Deployment we can Just Say what is the number of Replicas of your pod that you Require. In some cases you do not want to have a single replica of your container sometimes your load will be too high you might want to expose your application to a multiple concurrent users who can access your applications like you know you can say 100 users should go to Pod-1 100 users should go to Pod-2 I mean Replica-1 of Pod-1 and Replica-2 of Pod-2. We are Implementing High Availability, Load Balancing, Zero Down Time.




So Inside Our deployment.yaml file you can just say replica count as 2 and Using the Replica-Set Controller of Kubernetes It will Ensure that 2 Pods are Always Running as we have said Replica Count as 2. Controllers are Something Which Maintains a State in a Cluster, It Always Ensures that the Desired State & Actual State is Always Present on the Cluster.




REPLICASET - Replica-Set is a Kubernetes Controller and a Kubernetes Controller is a Golang Application that Kubernetes has Written which will Ensure that "The Desired State & Actual State is Always Present on the Cluster."












------------------------------------------------------------


# Practical
=============



NOTE - To List Out All the Resources Available in a Particular Namespace   [VERY IMP Question]
# kubectl get all -A


Step 1 - vim pod.yml

apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80




Step 2 - kubectl apply -f pod.yml 



Step 3 - kubectl get pods 

Output = 
NAME    READY   STATUS              RESTARTS   AGE
nginx   0/1     ContainerCreating   0          11s




Step 4 - kubectl get pods -o wide  [This will give all the Info of the Pod]

Output = 
NAME    READY   STATUS    RESTARTS   AGE     IP           NODE                        NOMINATED NODE   READINESS GATES
nginx   1/1     Running   0          2m14s   10.244.1.2   amir-cka-cluster3-worker2   <none>           <none>





Step 5 - kubectl describe pod nginx     [To get All the Info of the Pod Use the Below Command]




Step 6 - minikube ssh  ->   Copy the IP Address of the POD and do "curl 10.244.0.5"




Step 7 - Refer Documentation for Deployment.yml 

Link - https://kubernetes.io/docs/concepts/workloads/controllers/deployment/






Step 8 - vim deployment.yml and paste the file


apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80






Step 9 - kubectl apply -f deployment.yml


Once we Create a "DEPLOYMENT"  ->  It Will Create a "REPLICASET" for You and RS is Resp to Create  -> "POD"  [We can Check Below]



# $ kubectl get deploy
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   1/1     1            1           10s



# $ kubectl get rs
NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-647677fc66   1         1         1       19s



# $ kubectl get pods
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-647677fc66-dz82m   1/1     Running   0          16s







Step 10 - As we have done a Deployment and the No. of Replica is 1 so the K8s Controller which is Replica-Set It will Ensure that 1 Pod is Always Running Now If we delete the Pod 


$ kubectl delete pod nginx-deployment-647677fc66-dz82m
pod "nginx-deployment-647677fc66-dz82m" deleted






Step 11 - And We Are Watching the Pod by Running the Below Command Where it Shows Even Before the Pod was Terminated A New Pod is Up & Running Parallelly.


$ kubectl get pods -w
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-647677fc66-dz82m   1/1     Running   0          8m35s
nginx-deployment-647677fc66-dz82m   1/1     Terminating   0          9m40s
nginx-deployment-647677fc66-fm5ww   0/1     Pending       0          0s
nginx-deployment-647677fc66-fm5ww   0/1     Pending       0          0s
nginx-deployment-647677fc66-fm5ww   0/1     ContainerCreating   0          0s
nginx-deployment-647677fc66-dz82m   0/1     Completed           0          9m41s
nginx-deployment-647677fc66-dz82m   0/1     Completed           0          9m42s
nginx-deployment-647677fc66-dz82m   0/1     Completed           0          9m42s
nginx-deployment-647677fc66-fm5ww   1/1     Running             0          1s



